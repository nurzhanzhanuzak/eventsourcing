===============================
Tutorial - Part 4 - Projections
===============================

This part of the tutorial shows how the state of an event-sourced applications can be projected
into a `materialised view <https://en.wikipedia.org/wiki/Materialized_view>`_ that supports arbitrary queries.

As we saw in :doc:`Part 3 </topics/tutorial/part1>`, we can use the library's
:class:`~eventsourcing.application.Application` class to define an event-sourced
application. The state of an event-sourced application is recorded as a set of many events,
each of which is positioned in one of many "aggregate sequences" and also in the overall
"application sequence".

We can reconstruct an aggregate by selecting events from an aggregate sequences, and we can propagate
the state of an application by following its application sequence. But we can't query the current
state of an event-sourced application in an arbitrary way without firstly projecting the application
into a "read model" that is designed to support such a query.

So that such queries can be performed quickly, it is often useful to project the state of an event-sourced
application into a "materialised view", a projection of the state of the application that is stored in a database.
Such materialised views will be prepared and updated by processing the events of the event-sourced application,
usually by following the application sequence.

In the sections below we will explore how the events of an event-sourced applications can be processed into
materialised views that support queries that are not directly supported by event-sourced applications.

Let's begin by firstly considering materialised views, and then return to the processing of events.

Materialised views
==================

Materialised views are designed to support queries of the state of an event-sourced application that are not
directly supported by the event-sourced application itself. Therefore, every materialised view will need to have
at least one query method.

Materialised views will also need to be updated when events are processed. Therefore, every materialised view will
also need at least one command method.

Additionally, in order to ensure a materialised view is a reliably deterministic projection of the state of
an event-sourced application, it will need to track which events have been processed. This will be a common
aspect of all its command methods. We will need the materialised view to report the position of the last event
that has been processed, so that event processing can be stopped and resumed correctly. We will also need it
to track events both uniquely and atomically with the updating of the materialised view, so that effectively each
event is never successfully processed more than once. Because of the arbitrary nature of queries supported by
materialised views, this is the only common aspect shared by them all. In this sense, all materialised views are
special kinds of :ref:`tracking recorders <Tracking recorder>`.

For this reason, the library's abstract base class :class:`~eventsourcing.persistence.TrackingRecorder` can be
usefully extended, in arbitrary ways, to define an abstract interface for a materialised view. As we will see,
defining an abstract interface will allow us to define how the events of an event-sourced application are processed,
independently of any particular concrete implementation.

We can develop concrete materialised views by implementing the abstract interface whilst also extending the
library's concrete tracking recorder classes (:class:`~eventsourcing.popo.POPOTrackingRecorder`,
:class:`~eventsourcing.sqlite.SQLiteTrackingRecorder`, :class:`~eventsourcing.postgres.PostgresTrackingRecorder`,
etc.). Using these classes to implement concrete materialised views means that command methods that support event
tracking can be more easily implemented.

To show how this can work, let's create a materialised view for counting events that can record and reveal the number
of :ref:`"created" events <Created events>` and the number of :ref:`subsequent events <Subsequent events>`
that have been generated by an event-sourced application.

View test case
--------------

The ``EventCountersViewTestCase`` expresses requirements for recording and revealing the
number of "created" events, and the number of subsequent events, generated by an event-sourced application.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: EventCountersViewTestCase

It has a test method which begins by constructing an "event counters view" object. The view object is expected to be a
:class:`~eventsourcing.persistence.TrackingRecorder`, and therefore to have a
:func:`~eventsourcing.persistence.TrackingRecorder.max_tracking_id` method.

The test method calls query methods to get the counted number of "created" events, and to get the counted number of
subsequent events, according to the current state of the materialised view. The query methods are expected to return
integers. The values returned by the query methods are expected to be equal to the number of times the corresponding
command methods were called.

The test method calls command methods on the view object, to increment the counted number of "created" events, and to
increment the counted number of subsequent events.

The command methods are called with unique :ref:`tracking object <Tracking objects>`.
The value returned by :func:`~eventsourcing.persistence.TrackingRecorder.max_tracking_id` is expected to reflect
these tracking objects. The command methods are expected to raise an :class:`~eventsourcing.persistence.IntegrityError`
when called more than once with the same tracking object. The counted numbers are expected not to change when an
:class:`~eventsourcing.persistence.IntegrityError` is raised.


View interface
--------------

Towards satisfying this test, the ``EventCountersInterface`` class, shown below, extends the library's abstract base
class :class:`~eventsourcing.persistence.TrackingRecorder` by defining abstract command and query methods with the
expected method names and method signatures.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: EventCountersInterface

The query methods ``get_created_event_counter()`` and ``get_subsequent_event_counter()`` return integers and have no arguments.

The command methods ``incr_created_event_counter()`` and ``incr_subsequent_event_counter()`` return ``None``, and have a ``tracking``
argument expected to be an instance of the library's :class:`~eventsourcing.persistence.Tracking` class.


In-memory view
--------------

The ``POPOEventCounters`` class, shown below, implements the abstract interface using "plain old Python objects" to
count events in memory. It defines "private" attributes ``_created_event_counter`` and ``_subsequent_event_counter``,
whose values can be returned by the query methods and incremented by the command methods.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: POPOEventCounters

It inherits and extends the :class:`~eventsourcing.popo.POPOTrackingRecorder` class, using its database lock to
serialise commands, so that the data integrity of the counters is preserved. It uses the "private" methods
:func:`~eventsourcing.popo.POPOTrackingRecorder._assert_tracking_uniqueness` and :func:`~eventsourcing.popo.POPOTrackingRecorder._insert_tracking`
to avoid any event being counted more than once, whilst keeping track of which events have been processed so that
event-processing can be resumed correctly.

The test case ``TestPOPOEventCounters`` will show whether the ``POPOEventCounters`` class satisfies our
requirements. Running this test shows that it does.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: TestPOPOEventCounters


PostgreSQL view
---------------

Similarly, the ``PostgresEventCounters`` class, shown below, implements the abstract interface
``EventCountersInterface`` using PostgreSQL.
It defines a database table for event counters, and statements that select and increment the value
of counters in this table.

The ``_select_counter()`` method is used to select the current value of an event counter.
The ``_incr_counter()`` method of ``PostgresEventCounters`` is used to increment a named
event counter atomically in the same database transaction as a tracking object is recorded.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: PostgresEventCounters

It inherits and extends the :class:`~eventsourcing.postgres.PostgresTrackingRecorder` class, using the
:func:`~eventsourcing.postgres.PostgresDatastore.transaction` method of its datastore so that the data
integrity of the counters is preserved.

It uses the "private" :func:`_insert_tracking <eventsourcing.postgres.PostgresTrackingRecorder>` method of
:class:`~eventsourcing.postgres.PostgresTrackingRecorder` to avoid any event being counted more than once,
whilst keeping track of which events have been processed so that
event-processing can be resumed correctly.

The test case ``TestPostgresEventCounters`` will show whether the ``PostgresEventCounters`` class satisfies our
requirements. Running this test shows that it does.


.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: TestPostgresEventCounters

This test uses the library's :class:`~eventsourcing.persistence.InfrastructureFactory` to construct the materialised
view object, which is configured using environment variables. This powerful technique for constructing materialised
view objects is used internally by the library's projection runner class, which is described at the end of this
part of the tutorial.


Event-driven projections
========================

Letâ€™s now consider how the events of an event-sourced application can be projected into a materialised view.

The library's generic abstract base class :class:`~eventsourcing.projection.Projection` can be used to define how
the domain events of an event-sourced application will be processed. It is intended to be subclassed by users.

.. literalinclude:: ../../../eventsourcing/projection.py
    :pyobject: Projection

The :class:`~eventsourcing.projection.Projection` class is a `generic` class because it has one type argument, which is
expected to be the abstract interface of a materialised view that is also a subclass of
:class:`~eventsourcing.persistence.TrackingRecorder`. The type argument should be specified by users when defining a subclass of
:class:`~eventsourcing.projection.Projection`.

The :class:`~eventsourcing.projection.Projection` class has one required constructor argument,
:func:`view <eventsourcing.projection.Projection.__init__>`. This argument's type is bound
to the type argument of the class, and so should be a concrete instance of a materialised view.
This constructor argument will be assigned as an attribute of the constructed projection
object, and will be available to be used by subclass methods via the :data:`~eventsourcing.projection.Projection.view`
property, which is also typed with the type argument of the class.

The :class:`~eventsourcing.projection.Projection` class is an `abstract` class because it defines an abstract method
:func:`~eventsourcing.projection.Projection.process_event` that must be implemented by subclasses. Events will typically
be processed by calling command methods on the projection's tracking recorder, accessed via the :data:`~eventsourcing.projection.Projection.view`
property.

Counting events
---------------

For example, the ``EventCountersProjection`` class, shown below, processes events of an event-sourced application by
calling methods of a concrete instance of ``EventCountersInterface``.


.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: EventCountersProjection

The ``EventCountersProjection`` class inherits the :class:`~eventsourcing.projection.Projection`
class. The type argument of :class:`~eventsourcing.projection.Projection` is specified as the
``EventCountersInterface`` class, and so ``EventCountersProjection`` expects to be constructed with
a view object that implements this interface, such as ``POPOEventCounters`` or ``PostgresEventCounters``.

The ``EventCountersProjection`` class implements the abstract method :func:`~eventsourcing.projection.Projection.process_event`
of :class:`~eventsourcing.projection.Projection` by calling ``incr_created_event_counter()`` on its
:data:`~eventsourcing.projection.Projection.view` if the given event is an
:class:`Aggregate.Created <eventsourcing.domain.Aggregate.Created>` event, or ``incr_subsequent_event_counter()`` if the
given class is an :class:`Aggregate.Event <eventsourcing.domain.Aggregate.Event>`.


Running the projection
======================

Let's consider how to run the projection, so events of an event-sourced application can be counted.

The library's :class:`~eventsourcing.projection.ProjectionRunner` class is provided for the purpose
of running projections. A projection runner can be constructed with an application class, a projection
class, a materialised view class, and an environment that specifies the persistence modules
to be used by the application and the tracking recorder.

The projection runner will construct an instance of the given application class, and an instance of
the given projection class with an instance of the given tracking recorder class.

It will :ref:`subscribe to the application <Subscriptions>`, from the position indicated by the
:func:`~eventsourcing.persistence.TrackingRecorder.max_tracking_id` method of the  projection's
tracking recorder, and then call the :func:`~eventsourcing.projection.Projection.process_event`
method of the projection for each domain event yielded by the application subscription.

Because the projection runner starts a subscription to the application, it will first catch up by
processing already recorded events that have not yet been processed, and then it will continue
to process events that are subsequently recorded in the application's database.

The :class:`~eventsourcing.projection.ProjectionRunner` class has a :func:`~eventsourcing.projection.ProjectionRunner.run_forever`
method, which blocks until an optional timeout, or until an exception is raised by the projection or
by the subscription, or until the projection runner is stopped by calling its :func:`~eventsourcing.projection.ProjectionRunner.stop` method.
This allows an event processing component to be started and run independently as a
separate operating system process for a controllable period of time, and then to terminate in a controlled
way when there is an error. Exceptions raised whilst running the projection will be re-raised by the
:func:`~eventsourcing.projection.ProjectionRunner.run_forever` method. Operators of the system can examine
any errors and resume processing by reconstructing the runner. Some types of errors may be transient operational
errors, such as database connectivity, in which case the processing could be resumed automatically. Some errors
may be programming errors, and will require manual intervention before the event processing can continue.

The :func:`~eventsourcing.persistence.TrackingRecorder.wait` method of tracking recorders can be used
to wait until an event has been processed by the projection before calling a query method on the materialised view.


Counting events in memory
-------------------------

For example, the ``TestEventCountersProjection`` class, shown below, tests the ``EventCountersProjection``
projection class with the ``POPOEventCounters`` class.

The method ``test_event_counters_projection()`` constructs a runner, and from the runner gets references
to an event-sourced application "write model" and a materialised view "read model".
Events are generated in the event-sourced application "write model". The "created" and subsequent events are
processed, by updating the materialised view "read model", according to the logic of the ``EventCountersProjection``
projection.
The counted numbers of each kind of event are obtained from the "read model". The materialised view is
"eventually consistent" because the event processing is asynchronous, and so the
:func:`~eventsourcing.persistence.TrackingRecorder.wait` method is used to wait for the events to be
processed before querying the materialised view.
In this case, because we are generating and counting events in memory, we need to use the same
instance of the application and of the materialised view as the "write model" and the "read model".

The method ``test_run_forever_raises_projection_error()`` shows that after a ``SpannerThrown`` event
is generated by the event-sourced application, an error occurs with the event-processing, and an exception
representing this error is raised by the runner's :func:`~eventsourcing.projection.ProjectionRunner.run_forever`
method, and the materialised view's :func:`~eventsourcing.persistence.TrackingRecorder.wait` method times out.


.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: TestEventCountersProjection


Counting events in PostgreSQL
-----------------------------

The ``TestEventCountersProjectionWithPostgres`` extends ``TestEventCountersProjection``. It runs
``EventCountersProjection`` with the ``PostgresEventCounters`` class.

Because this test case uses a durable database for both the event-sourced application and the materialised view,
any instance of the application can be used to write events, and any instance of the materialised view can be used
obtain the counted number of events. This means, if this condfiguration were used in production, the event-sourced
application object and the materialised view object could be horizontally scaled, with the event-processing component
being run independently as a separate operating system process.

This is demonstrated by extending the test methods: to resume processing, to continue generating events, to
expect the event counters correctly report the total numbers of events that have been generated, and to show
that the event-processing error is still raised.


.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: TestEventCountersProjectionWithPostgres

The event-sourced application and the materialised view could, in this case, use separate databases. But in this
example they are configured more simply to use different tables in the same database.

See example :doc:`/topics/examples/fts-projection` for a more substantial example.


Exercises
=========

1. Replicate the code in this tutorial in your development environment.

2. Develop a projection that counts dogs and tricks from a ``DogSchool`` application.


Next steps
==========

* To continue this tutorial, please read :doc:`Part 5 </topics/tutorial/part5>`.
* For more information about event-driven projections, please read
  :doc:`the projection module documentation </topics/projection>`.
* See also the :ref:`Example projections`.
