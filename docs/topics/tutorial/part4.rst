===============================
Tutorial - Part 4 - Projections
===============================

This part of the tutorial shows how the state of an event-sourced application can be projected
into a `materialised view <https://en.wikipedia.org/wiki/Materialized_view>`_ that supports arbitrary queries.

As we saw in :doc:`Part 3 </topics/tutorial/part3>`, we can use the library's
:class:`~eventsourcing.application.Application` class to define an event-sourced
application. The state of an event-sourced application is recorded as a set of events,
each of which is positioned in one of many "aggregate sequences" and also in the overall
"application sequence".

We can reconstruct an aggregate by selecting events from an aggregate sequence, and we can propagate
the state of an application by following its application sequence. But we can only query the current
state of an event-sourced application in other ways by firstly projecting the application state
into a "read model" that is designed to support such queries.

So that such queries can be performed quickly, it is useful to project the state of an event-sourced
application into a read model that is stored in a database. Such "materialised views" are usually prepared
and updated by processing the events of the event-sourced application in a separate event-processing component,
which subscribes to the application sequence so that it can catch-up and then continue as further events
are recorded.

In the sections below we will explore how the events of event-sourced applications can be processed into
materialised views that support queries that are not directly supported by event-sourced applications.

Views
=====

Materialised views are primarily designed to support queries of the state of an event-sourced application that are
not directly supported by the event-sourced application itself. Therefore, every materialised view will need to have
at least one query method. Materialised views will also need to be updated when events are processed, therefore each
materialised view will also need at least one command method.

In order to ensure a materialised view is a reliable deterministic projection of the state of an event-sourced
application, it will need to track which events have been processed. We will need it to record the positions of
events that have been processed uniquely and atomically with the updating of the materialised view, so that effectively
each event is never successfully processed more than once. We will also need the materialised view to report the position
of the last event that has been processed, so that event processing can be stopped and resumed correctly. Because of the
arbitrary nature of queries supported by materialised views, this is the only common aspect shared by all materialised
views. In this sense, all materialised views are special kinds of :ref:`tracking recorders <Tracking recorder>`.

We can define an interface for a materialised view using the library's abstract :class:`~eventsourcing.persistence.TrackingRecorder`
class and develop concrete implementations using the library's concrete tracking recorder classes,
:class:`~eventsourcing.popo.POPOTrackingRecorder`, :class:`~eventsourcing.sqlite.SQLiteTrackingRecorder`, and
:class:`~eventsourcing.postgres.PostgresTrackingRecorder`. The interface will allow us to define how the materialised
view will be queried and how events will be processed independently of any concrete implementation. The concrete
tracking recorders make it easier to correctly implement command methods that record the positions of events uniquely
and atomically in a particular database.

To show how this can work, let's create a materialised view for counting events that can record and reveal the number
of :ref:`"created" events <Created events>` and the number of :ref:`subsequent events <Subsequent events>`
that have been generated by an event-sourced application.

View test case
==============

Let's begin by writing a test. The ``EventCountersViewTestCase`` shown below expresses requirements for recording and
revealing the number of events generated by an event-sourced application.

It begins by constructing an "event counters view" object. The view object is expected to be a
:class:`~eventsourcing.persistence.TrackingRecorder`, and therefore to have a
:func:`~eventsourcing.persistence.TrackingRecorder.max_tracking_id` method. This method will be called when
starting or resuming the processing of events, so that event-processing can run from the correct position
in an application sequence.

The test continues by calling query methods to get the counted number of "created" and subsequent events.
The query methods are expected to return integers. The values returned by the query methods are expected
to be equal to the number of times the corresponding command methods have been called.

The command methods are called to increment the counted number of events. The command methods are called
with a unique :ref:`tracking object <Tracking objects>`. The value returned by :func:`~eventsourcing.persistence.TrackingRecorder.max_tracking_id` is expected to reflect which tracking objects
have been recorded by the command methods. The command methods are expected to raise an :class:`~eventsourcing.persistence.IntegrityError`
when called more than once with the same tracking object. The counted numbers are expected not to change when an
:class:`~eventsourcing.persistence.IntegrityError` is raised. The view's :func:`~eventsourcing.persistence.TrackingRecorder.wait`
method is called with a position that has been recorded, expecting the method to return normally without raising
an exception. The :func:`~eventsourcing.persistence.TrackingRecorder.wait` method is called with a position that
has not been recorded, expecting that a ``TimeoutError`` will be raised.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: EventCountersViewTestCase


View interface
==============

Towards satisfying this test, the ``EventCountersInterface`` class shown below extends the library's abstract base
class :class:`~eventsourcing.persistence.TrackingRecorder` by defining abstract command and query methods with the
expected method names and method signatures.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: EventCountersInterface

The query methods ``get_created_event_counter()`` and ``get_subsequent_event_counter()`` return integers and have no arguments.

The command methods ``incr_created_event_counter()`` and ``incr_subsequent_event_counter()`` have a ``tracking``
argument expected to be an instance of the library's :class:`~eventsourcing.persistence.Tracking` class and return nothing.


In-memory view
==============

We can implement the interface so that the counted numbers of events are held in memory. The ``POPOEventCounters`` class,
shown below, implements the abstract interface using Python objects to hold the counted numbers of events in memory.
It defines "private" attributes ``_created_event_counter`` and ``_subsequent_event_counter``. The values of these
attributes are Python :class:`int` objects, initialised to be zero. The values of these attributes are returned by
the query methods, and incremented by the command methods.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: POPOEventCounters

It inherits and extends the :class:`~eventsourcing.popo.POPOTrackingRecorder` class, using its database lock to
serialise commands, so that the data integrity of the counters is preserved. It uses the "private" methods
:func:`~eventsourcing.popo.POPOTrackingRecorder._assert_tracking_uniqueness` and :func:`~eventsourcing.popo.POPOTrackingRecorder._insert_tracking`
to avoid any event being counted more than once, whilst keeping track of which events have been processed so that
event-processing can be resumed correctly.

The test case ``TestPOPOEventCounters`` will show whether the ``POPOEventCounters`` class satisfies our
requirements. Running this test shows that it does.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: TestPOPOEventCounters


PostgreSQL view
===============

Similarly, we can implement the interface to store the counted numbers of events in PostgreSQL. The ``PostgresEventCounters``
class, shown below, implements ``EventCountersInterface`` by defining a database table for event counters with SQL
statements that select and increment event counters.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: PostgresEventCounters

The ``_select_counter()`` method is used to select the current value of an event counter.
The ``_incr_counter()`` method is used to increment a named event counter atomically in the
same database transaction as a tracking object is recorded.

It inherits and extends the :class:`~eventsourcing.postgres.PostgresTrackingRecorder` class, using the
:func:`~eventsourcing.postgres.PostgresDatastore.transaction` method of its datastore so that the data
integrity of the counters is preserved.

It uses the "private" :func:`_insert_tracking() <eventsourcing.postgres.PostgresTrackingRecorder>` method of
:class:`~eventsourcing.postgres.PostgresTrackingRecorder` to avoid any event being counted more than once,
whilst keeping track of which events have been processed so that
event-processing can be resumed correctly.

The test case ``TestPostgresEventCounters`` will show whether the ``PostgresEventCounters`` class satisfies our
requirements. Running this test shows that it does.


.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: TestPostgresEventCounters

This test uses the library's :class:`~eventsourcing.persistence.InfrastructureFactory` to construct the materialised
view object, which is configured using environment variables. This powerful technique for constructing materialised
view objects is used internally by the library's projection runner class, which is described at the end of this
part of the tutorial.


Projections
===========

Let’s now consider how the events of an event-sourced application can be processed.

The library's generic abstract base class :class:`~eventsourcing.projection.Projection` can be used to define how
the domain events of an event-sourced application will be processed. It is intended to be subclassed by users.

.. literalinclude:: ../../../eventsourcing/projection.py
    :pyobject: Projection

The :class:`~eventsourcing.projection.Projection` class is a `generic` class because it has one type argument, expected
to be the interface of a materialised view, a subclass of :class:`~eventsourcing.persistence.TrackingRecorder`. The type
argument should be specified by users when defining a subclass of :class:`~eventsourcing.projection.Projection`, to
inform IDE code insight, command completion, and static type checking.

The :class:`~eventsourcing.projection.Projection` class has one required constructor argument,
:func:`view <eventsourcing.projection.Projection.__init__>`, and one property also called
:data:`~eventsourcing.projection.Projection.view`. The constructor argument is used to initialise the property.
The annotated type of both is bound to the type argument of :class:`~eventsourcing.projection.Projection`.
The given value of the constructor argument, and therefore the value of the property, should be a concrete instance
of a materialised view.

The :class:`~eventsourcing.projection.Projection` class is an `abstract` class because it defines an abstract method
:func:`~eventsourcing.projection.Projection.process_event` that must be implemented by subclasses. Events will typically
be processed by calling methods on :data:`~eventsourcing.projection.Projection.view`.

The  :class:`~eventsourcing.projection.Projection` class has a :py:attr:`~eventsourcing.projection.Projection.name`
attribute, which can be set on subclasses. It is expected to be a Python :class:`str`. It is used by projection
runners, when constructing a materialised view object, to select prefixed environment variables, and in some cases
to specify database table names used by the materialised view. The value used by the projection runner defaults to
the class name of the subclass.

The  :class:`~eventsourcing.projection.Projection` class has a :py:attr:`~eventsourcing.projection.Projection.topics`
attribute, which can be set on subclasses. It is expected to be a Python :class:`tuple` of :class:`str` objects,
that contains domain events :ref:`topics <Topics>`. Unless empty or undefined, projection runners will use these topics
when subscribing to an application, so that events can be filtered in the application database. The subscription will
then only yield events that have topics mentioned by this attribute. In many cases this will improve performance when
running a projection, by avoiding the cost of transporting and reconstructing events that will be ignored by the
projection. In some cases, filtering events by topic in this way will be necessary to avoid errors caused by attempting
to reconstruct domain event objects that have been recorded in the database which either your code or the library code
is not capable of reconstructing.

Example projection
==================

For example, the ``EventCountersProjection`` class, shown below, processes events of an event-sourced application by
calling methods of a concrete instance of ``EventCountersInterface``. It inherits the :class:`~eventsourcing.projection.Projection`
class, setting the type argument as ``EventCountersInterface`` class. It sets the :py:attr:`~eventsourcing.projection.Projection.name`
attribute as ``'eventcounters'``. It sets the :py:attr:`~eventsourcing.projection.Projection.topics` attribute
to mention the topics of the domain events processed by this projection.

The ``EventCountersProjection`` class implements the :func:`~eventsourcing.projection.Projection.process_event`
by calling the ``incr_created_event_counter()`` and ``incr_subsequent_event_counter()`` methods of ``EventCountersInterface``
available on :data:`~eventsourcing.projection.Projection.view`.

If the given event is an :class:`Aggregate.Created <eventsourcing.domain.Aggregate.Created>` event,
then ``incr_created_event_counter()`` is called. Alternatively,  ``incr_subsequent_event_counter()`` is called
if the given event is an :class:`Aggregate.Event <eventsourcing.domain.Aggregate.Event>`. An exception is raised
if the given event is a ``SpannerThrown`` event, to demonstrate error handling in process runners. Other kinds
of events can be handled by calling :func:`~eventsourcing.persistence.TrackingRecorder.insert_tracking` so that
progress along an application sequence can be recorded, for example if large gaps are spanned by an application
subscription returning checkpoints.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: EventCountersProjection


Runners
=======

Let's consider how to run the projection, so events of an event-sourced application can be counted.

The library's :class:`~eventsourcing.projection.ProjectionRunner` class is provided for the purpose
of running projections. A projection runner can be constructed with an application class, a projection
class, a materialised view class, and an optional environment :class:`Mapping` object that specifies run-time
configuration of the event-sourced application and the materialised view.

The projection runner will construct an instance of the given application class, and an instance of
the given projection class with an instance of the given materialised view class. Any items in the
given environment will be used to override any operating system environment variables, and the resulting
environment variables will be used when the application object is constructed and when the materialised
view class is constructed. The names of the application and of the projection are used to select prefixed
environment variables before defaulting to unprefixed names. In this way, the event-sourced application
can be configured separately from the materialised view.

It will :ref:`subscribe to the application <Subscriptions>`, from the position indicated by the
:func:`~eventsourcing.persistence.TrackingRecorder.max_tracking_id` method of the projection's
materialised view, and then call the :func:`~eventsourcing.projection.Projection.process_event`
method of the projection for each domain event yielded by the application subscription.

Because the projection runner starts a subscription to the application, it will first catch up by
processing already recorded events that have not yet been processed, and then it will continue
to process events that are subsequently recorded in the application's database.

The :class:`~eventsourcing.projection.ProjectionRunner` class has a :func:`~eventsourcing.projection.ProjectionRunner.run_forever`
method, which blocks until an optional timeout, or until an exception is raised by the projection or
by the subscription, or until the projection runner is stopped by calling its :func:`~eventsourcing.projection.ProjectionRunner.stop` method.
This allows an event processing component to be started and run independently as a
separate operating system process for a controllable period of time, and then to terminate in a controlled
way when there is an error, or when it is interrupted. Exceptions raised whilst running the projection will be re-raised by the
:func:`~eventsourcing.projection.ProjectionRunner.run_forever` method. Operators of the system can examine
any errors and resume processing by reconstructing the runner. Some types of errors may be transient operational
errors, such as database connectivity, in which case the processing could be resumed automatically. Some errors
may be programming errors, and will require manual intervention before the event processing can continue.

The :func:`~eventsourcing.persistence.TrackingRecorder.wait` method of materialised view objects can be used
to wait until an event has been processed by the projection before calling a query method on the materialised view.


Counting events in memory
=========================

For example, the ``TestEventCountersProjection`` class, shown below, tests the ``EventCountersProjection``
projection class with the ``POPOEventCounters`` class.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: TestEventCountersProjection

The method ``test_event_counters_projection()`` constructs a runner, and from the runner gets references
to an event-sourced application "write model" and a materialised view "read model".

In this case, because we are generating and counting events in memory, we need to use the same
instance of the application object and of the materialised view object as the projection runner
for generating events and for getting the counted numbers of events.

Events are generated in the event-sourced application "write model". The "created" and subsequent events are
processed, by updating the materialised view "read model", according to the logic of the ``EventCountersProjection``
projection. The counted numbers of each kind of event are obtained from the "read model". The materialised view is
"eventually consistent" because the event processing is asynchronous, and so the
:func:`~eventsourcing.persistence.TrackingRecorder.wait` method is used to wait for the events to be
processed before querying the materialised view.

The method ``test_run_forever_raises_projection_error()`` shows that after a ``SpannerThrown`` event
is generated by the event-sourced application, an error occurs with the event-processing, and an exception
representing this error is raised by the runner's :func:`~eventsourcing.projection.ProjectionRunner.run_forever`
method. Because the event will not successfully be processed, the materialised view's :func:`~eventsourcing.persistence.TrackingRecorder.wait`
method will time out.


Counting events in PostgreSQL
=============================

The ``TestEventCountersProjectionWithPostgres`` class extends ``TestEventCountersProjection`` and runs
``EventCountersProjection`` with the ``PostgresEventCounters`` class.
Because this test case uses a durable database for both the event-sourced application and the materialised view,
any instance of the application can be used to write events, and any instance of the materialised view can be used to
obtain the counted numbers of events. If a durable database is used in production, the event-sourced
application object and the materialised view object could be horizontally scaled, with the event-processing component
running as a separate operating system process. This is demonstrated by extending the test methods:
to resume processing by reconstructing the projection runner, to construct separate instances of the event-sourced
application and of the materialised view, to continue generating events using the separate instance of the event-sourced
application, to query the counted numbers of events using the separate instance of the materialised view, to expect
the obtained counted numbers of events correctly report the total numbers of events that have been generated, and to
show that the event-processing error is still raised and that the event-processing has not continued after the error
caused by the ``SpannerThrown`` event. The event-sourced application and the materialised view could also use separate
databases. But in this example they are configured more simply to use different tables in the same database.

.. literalinclude:: ../../../tests/projection_tests/test_projection.py
    :pyobject: TestEventCountersProjectionWithPostgres


Exercises
=========

1. Replicate the code in this tutorial in your development environment.

2. Develop a projection that counts dogs and tricks from a ``DogSchool`` application.


Next steps
==========

* Read the :doc:`projection module documentation </topics/projection>`.
* See also the :ref:`Example projections`.
* To continue this tutorial, please read :doc:`Part 5 </topics/tutorial/part5>`.
