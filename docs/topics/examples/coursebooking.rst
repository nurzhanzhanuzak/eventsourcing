.. _DCB example 1:

1 - Course booking - with aggregates
====================================

This example introduces the `course subscription <https://dcb.events/examples/course-subscriptions/>`_
challenge, used often when discussing `dynamic consistency boundaries <https://dcb.events/>`_. The
challenge is to enforce a rule when enrolling students on courses that no student can join more
than a given number of courses, and no course can accept more than a given number of students.

Dynamic consistency boundaries is a new variant of event sourcing presented in a
`humorously provocative way <https://sara.event-thinking.io/2023/04/kill-aggregate-chapter-1-I-am-here-to-kill-the-aggregate.html>`_
as "killing the aggregate". One idea from the DCB community is that the aggregates of DDD
establish consistency boundaries that are not always appropriate. The considerations
motivating DCB are broader than this, however. A more general scheme has been proposed that
involves a single sequence of events (an "application sequence" in the terminology of this library)
in which each event has a type, data, and any number of tags. Recorded events have an assigned position
in the application sequence. For this reason they are referred to as "sequenced events". A command will
query for recorded events with types and tags, and project those events into a state from which a decision
can be made, generating a new event. The highest position of the set of received sequenced events is used
when recording new events generated by a command. Consistency of recorded state is maintained by using that
sequence position, along with the same query, to check that no new events have been recorded. The combination
of the query and the last known position is referred to as the "append condition". If this condition fails
an exception is raised and no events are recorded. Otherwise, all the new events are recorded and each is
assigned a monotonically increasing position in the application sequence. Something like event-sourced
aggregates can be implemented in this scheme by using a tag to indicate an aggregate ID. Recorded events
can than cut across different aggregate sequences by having more than one tag.

Later examples will introduce the DCB approach to event sourcing. However, this example meets the
challenge with event-sourced aggregates, by showing that it is possible, and entirely legitimate,
to extended the transactional consistency boundary when using event-sourced aggregates to include
more than one aggregate.

But mostly, here, we are setting the scene for the DCB examples with a test case that will be satisfied
first with the more familiar event-sourced aggregate style of event sourcing, and then again in the
:doc:`next example </topics/examples/coursebooking-dcb>` using the "raw" style for "dynamic consistency
boundaries" described in the DCB specification, to show the basic ideas of DCB directly.

And then again later with a :doc:`refactored and hopefully more refined </topics/examples/coursebooking-dcb-refactored>`
style for DCB that is more usable, just like the :ref:`declarative syntax <Declarative syntax>` for
event-sourced aggregate is more usable than writing business logic directly against an
:ref:`application recorder <Application recorder>`.

With these examples, the DCB approach can be introduced and examined, and different styles can be compared.

Test case
---------

The test case below has students and courses being registered, with students joining courses, and some
conditions that should lead to errors. An application-under-test is exercised twice, once without any
configuration so that it will store events in memory, and once with configuration for recording events
in PostgreSQL.

.. literalinclude:: ../../../examples/coursebooking/test_application.py
    :pyobject: TestEnrolment

Interface
---------

The interface used by the test case is defined as a Python protocol class. This allows structural subtyping.

.. literalinclude:: ../../../examples/coursebooking/interface.py
    :pyobject: EnrolmentProtocol

Exception classes used in the test case are also defined separately.

.. literalinclude:: ../../../examples/coursebooking/interface.py
    :pyobject: TooManyCoursesError

.. literalinclude:: ../../../examples/coursebooking/interface.py
    :pyobject: FullyBookedError

.. literalinclude:: ../../../examples/coursebooking/interface.py
    :pyobject: AlreadyJoinedError

.. literalinclude:: ../../../examples/coursebooking/interface.py
    :pyobject: StudentNotFoundError

.. literalinclude:: ../../../examples/coursebooking/interface.py
    :pyobject: CourseNotFoundError


Domain model
------------

The domain model shown below defines an event-sourced aggregate class :class:`~examples.coursebooking.domainmodel.Course`
for courses that students can join, and an event-sourced aggregate class :class:`~examples.coursebooking.domainmodel.Student`
for students that may join courses. These aggregate classes are implemented using the concise "declarative syntax" supported
by this library. These aggregate classes are coded to use string IDs as demonstrated
in :doc:`example 11  </topics/examples/aggregate11>`.

.. literalinclude:: ../../../examples/coursebooking/domainmodel.py
    :pyobject: Course

.. literalinclude:: ../../../examples/coursebooking/domainmodel.py
    :pyobject: Student


Application
-----------

The event-sourced application shown below uses the :class:`~examples.coursebooking.domainmodel.Course`
and :class:`~examples.coursebooking.domainmodel.Student` aggregate classes from the domain model,
and implements the enrolment protocol with its methods for registering students and for registering courses,
for joining students with courses, for listing students for a course, and for listing courses for a student.

Please note, the consistency boundary for joining a course involves atomically recording new events from two
aggregates, one student and one course, in the same database transaction. The preservation of recorded consistency
is tested in the extra test case below. At the time of writing, this possibility is not mentioned in the list of
`traditional approaches <https://dcb.events/examples/course-subscriptions/#traditional-approaches>`_ on the dynamic
consistency boundaries website, which lists only three options: eventual consistency, larger aggregate, reservation
pattern.

.. literalinclude:: ../../../examples/coursebooking/application.py
    :pyobject: Enrolment

.. literalinclude:: ../../../examples/coursebooking/test_application.py
    :pyobject: TestEnrolmentConsistency


It has been a common misapprehension that the "consistency boundary" notion in DDD is equal to
one aggregate (`"by definition, the aggregate is the boundary of consistency" <https://sara.event-thinking.io/2023/04/kill-aggregate-chapter-2-the-aggregate-does-not-fit-the-storytelling.html>`_).
The actual idea from DDD is that a database transactional consistency boundary must not be less
than one aggregate. The meaning of "not less than" is "greater than or equal to". A consistency boundary
that includes more than one aggregate, or indeed other things, has always been permitted by DDD.
Nevertheless, there are other reasons why DCB is an interesting novel approach for event sourcing,
so let's continue by :doc:`implementing the specification </topics/examples/coursebooking-dcb>` directly.



Code reference
--------------

.. automodule:: examples.coursebooking.domainmodel
    :show-inheritance:
    :member-order: bysource
    :members:
    :undoc-members:
    :special-members: __init__

.. automodule:: examples.coursebooking.application
    :show-inheritance:
    :member-order: bysource
    :members:
    :undoc-members:
    :special-members: __init__

.. automodule:: examples.coursebooking.test_application
    :show-inheritance:
    :member-order: bysource
    :members:
    :undoc-members:
    :special-members: __init__

